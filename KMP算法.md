Knuth-Morris-Pratt三人研发的算法
## 步骤
1.求出模式串的next数组
2.进行匹配

假设待匹配串长$n$,模式串长$m$.
### 求出模式串的next数组
- 在传统的BM暴力匹配算法中,做了很多无效的匹配,导致时间复杂度达到了$O(m*n)$.
#### 字符串的前缀和后缀
- **前缀**:以第一个字符开头,**不包含末尾字符**的原字符串的子字符串;
- **后缀**:以最后一个字符结尾,**不包含首字符**的原字符串的子字符串;
#### next数组
- 对于索引$i$,$next[i]$表示前$i$个字符中最长的公共前后缀——相同的前后缀的最大长度;
- 引入$next$数组之后,主串在匹配过程中就无需回退,因为最长的公共前后缀注定了主串不可能在最大后缀之前开始与模式串匹配成功
#### next数组的构造
为了编程的方便,将最大公共前后缀长度为0的位置定义为$next[i]=-1$.
思路:本质上求next数组的过程就是**自己与自己匹配的过程,不过一个从索引0开始,一个从索引1开始.**
- 考虑两个指针,从0开始的即为前缀,从1开始的即为后缀;
- 若$s[i]=s[j]$,说明前$j+1$个字符的最大公共前后缀长度为前$j$个加1,即$next[j+1]=next[j]+1$;
- 若$s[i]\neq s[j]$,则将 $i$ 回退至$next[i]$的位置,直到 $i=-1$.
```C++
//构造next数组
void getNext(string s,vector<int>& next){
	next.resize(s.size());//初始化
	next[0]=-1;//第一个元素的最大公共前后缀长度必然为0
	int i=0;int j=1;//初始化前后缀指针
	while(j<s.size()-1){//注意溢出问题,j++之后才进行next赋值
	if(i==-1||s[i]==s[j]){//相等时,顺延加1
	i++;
	j++;
	next[j]=i;
	}
	else{
	i=next[i];//不等时,回退继续
	}
	}
}
```
#### 匹配过程
过程:主串和模式串两个指针,若相等则同时后移;若不相等则模式串指针回退到$next[i]$的位置,继续直到相等或者等于-1,则主串后移一位从0开始重新匹配.
```c++
int KMP(string s,string p){//s为主串,p为模式串
	vector<int> next;
	int i=0;int j=0;//初始化主串和模式串指针
	getNext(p,next);
	while(j<s.size()){
		if(p[i]==s[j]){
			i++;
			j++;
		}
		else{
		if(next[i]==-1){//等于-1时的特殊处理,即将主串后移一位,子串从0开始匹配
			j++;
			i=0;
		}
		else{
		i=next[i];
		}//else
		}//else
		if(i==p.size())return j-i;
	}//while
	return -1;
}
```
## 复杂度分析
- ### 空间复杂度:
	- 使用了 $next$ 数组,空间复杂度为 $O(m)$.
- ### 时间复杂度:
	- 虽然在构造 $next$ 数组和匹配的过程中都有可能不断地回退,**但回退的次数始终是小于主串的索引的**,所以kmp算法的时间复杂度为 $O(m+n)$.